##### Основная проблема: 
__мы не проговорили концепцию cinterop__ и то что я вижу - сильно расходится с моим представлением о том, как я бы решал задачу, если она была бы с нуля. Мне непонятен rationale  некоторых архитектурных решений, и я, возможно, предлагаю решение, несовместимое с намерениями. Но я этих намерений не знаю.

Пример:
```C++
    class CppTest {
    public:
        CppTest(const CppTest& other) { /*non-trivial copy ctor*/ }
        virtual int foo();
    };
    CppTest retByValue();
```
Чтобы корректно использовать такой объект из котлина, мне было бы достаточно аллоцировать memory block в памяти, доступной для натива. Затем:
```C++
    extern "C" void test_kniBridge0 (void* memblock) {
        new(memblock) CppTest(retByValue());
    }	
```
Аллоцировать можно прямо в нативном хипе обычным malloc'ом. Теперь по этому адресу находится валидный объект и я могу использовать его как receiver:
```C++
    extern "C" int32_t test_kniBridge1 (void* p0) {
        return ((CppTest*)p0)->foo();
    }
```
Осталось только запомнить указатель внутри котлиновского объекта a la smart ptr и делегировать в натив все методы как родные. Причем для этого уже есть всё что нужно:
```Kotlin
    class CppTest(rawPtr: NativePtr) : CStructVar(rawPtr) {
        fun foo(): Int {
            return kniBridge1(rawPtr)
        }
    }
```
Разумеется, потом придется вызвать деструктор - нет RAII (память можно освободить автоматически).

Но cinterop предлагает использовать `useContents { foo() }]`, который (о ужас!) создаёт временную копию побитовым копированием. Утверждается, что CValue - это immutable block. Почему _immutable_, и зачем мне _ещё одна_ копия, если я только что создал свой собственный экземпляр, причём в той памяти, где мне удобно? Это дорого, и побитовое не работает для нетривиальных объектов. А создавать временную копию конструктором - маразм, потому что прототип для этой копии - только что созданный специально для меня такой же точно объект, и я не знаю, что может натворить лишний вызов конструктора. Я не придумал мотивации для такого решения в рамках kotlin-native, который является (вроде бы) нормальным нативным приложением.

Абсолютно всю работу с нативными объектами (включая создание) надо делегировать в натив, а в котлине хранить только cpp_object_handler. Любой приличный объект будет думать, что свободно распоряжается хипом, и нигде кроме нативного хипа жить не сможет. Взять хотя бы std::vector или string.  И, конечно, никаких лищних копирований. 

Пока оставил это как есть, с неправильно работающим place и useContents - до прояснения концепции.

Чтобы закончить с темой "разрыва шаблона": Я ожидал, что котлиноский CppClass будет просто holder'ом нативного указателя (handler). Просто одно непрозрачное число. Собственно, так оно и сделано. Но зачем тогда нативный API при генерации в котлин использует нативные CValueRef<CppClass>, а не котлиновский CppClass (и пусть генератор вставит rawPtr где надо)? Сейчас получаются тяжеловесные многословные конструкции с getValue, ptr, pointed и т.д. И я вижу, что Indexer.kt нигде не использует сгенерённые обертки CXCursor, CXType - а только CValue (зачем тогда их сгенерили?). Вероятно, из-за многословия и из-за описанной выше проблемы return by value. Короче, пробразованием типов должен заниматься компилятор (генератор), а программист может (изредка) помочь в случае неоднозначности. 


__Костыль visitChildren вместо indexDeclaration__ для парсинга классов и функций. 

Проблема в том, что IndexDeclaration не отличает класс от темплейта (и функцию от темплейтной функции). Курсор внутри дерева indexDeclaration для темплейтов имеет kind CXCursorKind.CXCursor_ClassDecl (или StructDecl) вместо ожидаемого  CXCursor_ClassTemplate. Но если разобрать дерево через visitChildren - то курсор правильный. Поэтому, если язык C++, то я разбираю классы через visitChildren (и отбрасываю темплейты, пока не поддержаны). Я времнно оставил такого франкенштейна, когда часть сущностей парсится через indexDeclaration, а часть через visitChildren. Я думаю, что надо всё перенести в visitChildren, но у меня не было возможности протестить все сценарии в plain C и ObjC. Такой рефакторинг - не для тестового задания. По той же причине я не стал втыкать свой код в имеющийся visitChildren для ObjCб а написал отдельный - потому что мне нужен был CXChildVisit_Recurse, а там был CXChildVisit_Continue и я боялся сломать ObjC, который не умею как следует протестить.

- Спорное решение про throw Error("Native interop types constructors must not be called directly")  

Вообще, какая-то путаница между котлиновским классом и CValue. Или у меня проблема с тем, что концепция не озвучена как следует, и я её понимаю иначе. 

Например, есть `class CXType`, но им никто не пользуется, потому что в нативном API всюду CValue<CXType>, а преобразовывать из одного в другой - лишние буквы. В результате прикостыляли вручную написанный CValue<CXType>.kind,  при том что есть сгенерённый CXType.kind. Я предположил, что, разница между CValue<CXType> и CXType(rawPtr)  возникла как разница между объектом by value и указателем в хип. Но, реально, мне неважно где аллоцирован memory block для объекта: на нативном стеке (return by value) или в хипе, если я удерживаю этот блок по unique_ptr на стеке. Хотя unique_ptr указывает в хип, но семантика получается - как у стекового объекта. И я могу использовать холдер CXType(rawPtr) так, как будто это не холдер, а собственно объект - в исключительном владении у меня. 

Что я предлагаю: делать прозрачный interop, т.е. чтобы котлиновский прокси-класс MyCppClass можно было использовать в нативном API напрямую. Реализация объекта - как и сейчас,
`class MyCppClass(rawPtr: NativePtr) : CStructVar(rawPtr)` - то есть это holder. Разница в том, что 1) создаю его конструктором, который внутри вызывает обычный new и аллоцирует в нативном хипе 2) API binding сгенерён так, чтобы не писать лишних слов: `fun clang_getCursorType(C: CXCursor): CXType`3) Если  объект у меня - не из конструктора, а просто какая-то функция вернула объект по значению - то я сгенерил move/copy ctor, чтобы переместить возвращенный объект с нативного стека в хип, и пусть copy elision или RVO обеспечит оптимизацию: 




* Improvements
	+ getMethod invokes getFunction with additional block (lambda) parameter


Conceptual
==========

0. Internal linkage. 
Сейчас сущности с internal linkage (static & anon namespace) не фильтруются, биндинг на них создаётся (все функции в .def в тестах написаны со словом static). Фактически, строим так, как будто C включён в котлиновский исходник. В таком случае, эти сущности должны биндиться как internal, причем каждый С-ник надо компилировать, как отдельный translation unit, иначе будут конфликты. 
	- Это нормальный подход, если моё намерение - расширить (extend) нативную имплементацию на котлине.
	- Если моё намерение - затащить нативную библиотеку, то я компилирую все публичные хедеры как один translation unit, при этом лучше зафильтровать static. 
	- Проблема некритична, потому что в публичных хедерах static и anon namespace не встречается. Зато часто в c/cpp имплементации. Лучше быть последовательным в этом вопросе.
	
0. Что делать с protected и private? Я пока выключил. Технически, сейчас котлиновский класс соответствует C++ ссылке на объект, а не derived class, т.е. должен иметь доступ только к public. IMHO: это неправильно, в такой логике невозможно реализовать C++ callbacks (оверрайдить виртуальные методы, в т.ч. приватные). See below.

0. Derive vs Use. Хотелось бы рассматривать котлиновский класс как наследник C++ класса. Решает массу проблем и вообще удобно. Но для этого надо решить вопрос автоматического вызова деструктора на созданном объекте. See below.

0. Конструкторы-деструкторы надо доработать. Вопрос концептуальный, требует обсуждения. И это довольно большая работа. Моё предложение: надо различать 3 сущности: 
	- Явно аллоцированный объект с владением: alloc + init (т.е. placement new) и парный к нему destroy (это this->~MyClass()), деаллокация автоматическая или ручная
	- Holder, владеющий указатель на объект, созданный в нативном хипе по new MyClass() и парный к нему delete. Это аналог std::unique_ptr. 
	- Non-owning holder без передачи ownership, т.е. невладеюший указатель. Освобождать не надо. Аналог C raw pointer.
	- Можно замапить std::shared_ptr на котлин тип с acquire/release парой.

0. C++ move/copy, value semantics, transfer ownership - популярные C++ идиомы. Они плохо ложатся на нынешнюю реализацию - недорешённый маппинг C++ идиом на котлин (или решённый - то не артикулированный в достаточной мере, я не нашёл ничего).
	- Для C++ разработчика важно различать: a) совместный доступ к объекту, или уникальный b) у кого ownership. Для сиплюсера почти нет разницы между unique_ptr и by value - важно тольо то, что ownership у меня, и ни у кого больше доступа к объекту нет. Точка или стрелка - всё равно. А shared_ptr / raw pointer /reference - совсем другое.  Сейчас забинденный в котлин тип не отражает эти понятия. 
	- Value semantics - очень модная тема,  без этого ни одну современную C++ библиотеку не затащишь. Нужна концептуальная доработка cinterop.

0. Поля классов сейчас собираются через clang_Type_visitFields. Это нехорошо, потому что для методов и статических полей нет соответствующего API. Надо рефакторить и все делать однотипно - через visitChildren с разбором сразу всех возможных CXCursorKind. Пока оэто отложил, как следчтвие - не сделаны static fields (CXCursor_VarDecl)

0. Надо замапить самые важные std типы: string, containers, smart pointers

0. Сейчас работа с C/C++ из котлина выглядит неестественно, многословная. Interop должен быть seamless. Без лишних interpretPointed, rawValue etc. Но это требует определенного пересмотра концепции (type matching)

0. Override С++ методов в котлине (callbacks) Можно сделать через обертки (генерим C++ класс-наследник у которого каждый метод перевызывает соответствующий котлинвский метод как plain C. Но хорошо бы генерить эти обертки только on demand, т.е. когда компилятор видит, что котлин хотел бы перегрузить соответствующий метод.

Design issues
-------------

0. В контейнере members может лежать IncompleteField. Это имело бы смысл, если Incomplete - такой lazy тип, который позже можно, например, зарезолвить. Но это не предусмотрено - так что зачем добавлять dummy, надо было просто пропустить

0. getArrayLength(type: ArrayType) сделана приватным методом StructStubBuilder'а. Должна быть или свободной функцией, или (лучше) extension: ArrayType.getArrayLength() 

FIXME
=====
1. 
```
SkTime-build/kotlin/skia/skia.kt:1793:5: error: conflicting overloads: public final fun mapRect(rect: CValuesRef<SkRect>?): Boolean defined in skia.SkMatrix, public final fun mapRect(src: CValuesRef<SkRect>?): CValue<SkRect> defined in skia.SkMatrix
    fun mapRect(rect: CValuesRef<SkRect>?): Boolean {
```
Source:
```C++
    bool mapRect(SkRect* rect) const;
    SkRect mapRect(const SkRect& src) const;
```
Обе сигнатуры мапятся в CValuesRef<SkRect>?. Надо сделать LVRef -> notNullable

