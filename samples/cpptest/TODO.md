- заменить memcpy на присваивание / copy ctor


* Improvements
	+ getMethod invokes getFunction with additional block (lambda) parameter


- Спорное решение про throw Error("Native interop types constructors must not be called directly")  

Вообще, какая-то путаница между котлиновским классом и CValue. Или у меня проблема с тем, что концепция не озвучена как следует, и возможны разные трактовки. 

Например, есть `class CXType`, но им никто не пользуется, потому что в нативном API всюду CValue<CXType>, а преобразовывать из одного в другой - лишние буквы. В результате прикостыляли вручную написанный CValue<CXType>.kind,  при том что есть сгенерённый CXType.kind. Я предположил, что, разница между CValue<CXType> и CXType(rawPtr)  возникла как разница между объектом by value и указателем в хип. Но, реально, мне неважно где аллоцирован memory block для объекта: на нативном стеке (return by value) или в хипе, если я удерживаю этот блок по unique_ptr на стеке. Хотя unique_ptr указывает в хип, но семантика получается - как у стекового объекта. И я могу использовать холдер CXType(rawPtr) так, как будто это не холдер, а собственно объект - в исключительном владении у меня. 

Что я предлагаю: делать прозрачный interop, т.е. чтобы котлиновский прокси-класс MyCppClass можно было использовать в нативном API напрямую. Реализация объекта - как и сейчас,
`class MyCppClass(rawPtr: NativePtr) : CStructVar(rawPtr)` - то есть это holder. Разница в том, что 1) создаю его конструктором, который внутри вызывает обычный new и аллоцирует в нативном хипе 2) API binding сгенерён так, чтобы не писать лишних слов: `fun clang_getCursorType(C: CXCursor): CXType`3) Если  объект у меня - не из конструктора, а просто какая-то функция вернула объект по значению - то я сгенерил move/copy ctor, чтобы переместить возвращенный объект с нативного стека в хип, и пусть copy elision или RVO обеспечит оптимизацию: 




Conceptual
==========

0. Internal linkage. 
Сейчас сущности с internal linkage (static & anon namespace) не фильтруются, биндинг на них создаётся (все функции в .def в тестах написаны со словом static). Фактически, строим так, как будто C включён в котлиновский исходник. В таком случае, эти сущности должны биндиться как internal, причем каждый С-ник надо компилировать, как отдельный translation unit, иначе будут конфликты. 
	- Это нормальный подход, если моё намерение - расширить (extend) нативную имплементацию на котлине.
	- Если моё намерение - затащить нативную библиотеку, то я компилирую все публичные хедеры как один translation unit, при этом лучше зафильтровать static. 
	- Проблема некритична, потому что в публичных хедерах static и anon namespace не встречается. Зато часто в c/cpp имплементации. Лучше быть последовательным в этом вопросе.
	
0. Что делать с protected и private? Я пока выключил. Технически, сейчас котлиновский класс соответствует C++ ссылке на объект, а не derived class, т.е. должен иметь доступ только к public. IMHO: это неправильно, в такой логике невозможно реализовать C++ callbacks (оверрайдить виртуальные методы, в т.ч. приватные). See below.

0. Derive vs Use. Хотелось бы рассматривать котлиновский класс как наследник C++ класса. Решает массу проблем и вообще удобно. Но для этого надо решить вопрос автоматического вызова деструктора на созданном объекте. See below.

0. Конструкторы-деструкторы надо доработать. Вопрос концептуальный, требует обсуждения. И это довольно большая работа. Моё предложение: надо различать 3 сущности: 
	- Явно аллоцированный объект с владением: alloc + init (т.е. placement new) и парный к нему destroy (это this->~MyClass()), деаллокация автоматическая или ручная
	- Holder, владеющий указатель на объект, созданный в нативном хипе по new MyClass() и парный к нему delete. Это аналог std::unique_ptr. 
	- Non-owning holder без передачи ownership, т.е. невладеюший указатель. Освобождать не надо. Аналог C raw pointer.
	- Можно замапить std::shared_ptr на котлин тип с acquire/release парой.

0. C++ move/copy, value semantics, transfer ownership - популярные C++ идиомы. Они плохо ложатся на нынешнюю реализацию - недорешённый маппинг C++ идиом на котлин (или решённый - то не артикулированный в достаточной мере, я не нашёл ничего).
	- Для C++ разработчика важно различать: a) совместный доступ к объекту, или уникальный b) у кого ownership. Для сиплюсера почти нет разницы между unique_ptr и by value - важно тольо то, что ownership у меня, и ни у кого больше доступа к объекту нет. Точка или стрелка - всё равно. А shared_ptr / raw pointer /reference - совсем другое.  Сейчас забинденный в котлин тип не отражает эти понятия. 
	- Value semantics - очень модная тема,  без этого ни одну современную C++ библиотеку не затащишь. Нужна концептуальная доработка cinterop.

0. Поля классов сейчас собираются через clang_Type_visitFields. Это нехорошо, потому что для методов и статических полей нет соответствующего API. Надо рефакторить и все делать однотипно - через visitChildren с разбором сразу всех возможных CXCursorKind. Пока оэто отложил, как следчтвие - не сделаны static fields (CXCursor_VarDecl)

0. Надо замапить самые важные std типы: string, containers, smart pointers

0. Сейчас работа с C/C++ из котлина выглядит неестественно, многословная. Interop должен быть seamless. Без лишних interpretPointed, rawValue etc. Но это требует определенного пересмотра концепции (type matching)

0. Override С++ методов в котлине (callbacks) Можно сделать через обертки (генерим C++ класс-наследник у которого каждый метод перевызывает соответствующий котлинвский метод как plain C. Но хорошо бы генерить эти обертки только on demand, т.е. когда компилятор видит, что котлин хотел бы перегрузить соответствующий метод.

Design issues
-------------

0. В контейнере members может лежать IncompleteField. Это имело бы смысл, если Incomplete - такой lazy тип, который позже можно, например, зарезолвить. Но это не предусмотрено - так что зачем добавлять dummy, надо было просто пропустить

0. getArrayLength(type: ArrayType) сделана приватным методом StructStubBuilder'а. Должна быть или свободной функцией, или (лучше) extension: ArrayType.getArrayLength() 

FIXME
=====
1. 
```
SkTime-build/kotlin/skia/skia.kt:1793:5: error: conflicting overloads: public final fun mapRect(rect: CValuesRef<SkRect>?): Boolean defined in skia.SkMatrix, public final fun mapRect(src: CValuesRef<SkRect>?): CValue<SkRect> defined in skia.SkMatrix
    fun mapRect(rect: CValuesRef<SkRect>?): Boolean {
```
Source:
```C++
    bool mapRect(SkRect* rect) const;
    SkRect mapRect(const SkRect& src) const;
```
Обе сигнатуры мапятся в CValuesRef<SkRect>?. Надо сделать LVRef -> notNullable

